#!/bin/sh

# Git Push 안전성 검증 파이프라인
# 1. 시크릿 키 검증
if command -v gitleaks >/dev/null 2>&1; then
  echo "▶ push 전 gitleaks로 시크릿 스캔을 실행합니다..."
  gitleaks detect --no-git --source . --redact --no-banner
else
  echo "⚠️ gitleaks가 설치되어 있지 않아 시크릿 스캔을 건너뜁니다."
  echo "   설치 방법: macOS → brew install gitleaks / Windows → choco install gitleaks"
fi

# 2. 브랜치 패턴 검사
BRANCH_NAME=$(git symbolic-ref --short HEAD)
if ! echo "$BRANCH_NAME" | grep -Eq '^(main|release|dev|hotfix|feat\/[a-z0-9._-]+|fix\/[a-z0-9._-]+|refactor\/[a-z0-9._-]+|test\/[a-z0-9._-]+|docs\/[a-z0-9._-]+|chore\/[a-z0-9._-]+)$'; then
  echo "🚫 브랜치 이름 잘못 작성함!!"
  echo "이 중에 하나만 허용: main, release, dev, hotfix, <type>/<desc>"
  exit 1
fi

# 3. 환경 변수 유효성 검증
echo "Push 전 환경 변수 유효성 검증..."
yarn env:check || exit 1

# 4. 타입 안전성 검증
echo "Push 전 타입 안전성 검증..."
yarn typecheck || exit 1

# 5. 단위 테스트(Jest + RTL)
echo "...테스트 파일 수집 중..."

### 1) 현재 commit 단계의 스테이징 영역 테스트 파일 수집
STAGED_FILES=$(git diff --cached --name-only --diff-filter=AMR 2>/dev/null || true)
STAGED_TESTS=$(printf "%s\n" "$STAGED_FILES" | grep -E '(^|/)(__tests__/.*|.*\.(test|spec)\.[tj]sx?)$' || true)

### 2) 현재 commit 단계에 테스트 파일이 없을 경우 이전 테스트 파일 수집 (변경된 테스트 파일에 대한 테스트를 진행하기 위해서)
if git rev-parse --abbrev-ref @{upstream} >/dev/null 2>&1; then
  BASE=$(git merge-base HEAD @{upstream})
else
  BASE=$(git rev-list --max-parents=0 HEAD)
fi
RANGE_FILES=$(git diff --name-only --diff-filter=AMR "$BASE"...HEAD 2>/dev/null || true)
RANGE_TESTS=$(printf "%s\n" "$RANGE_FILES" | grep -E '(^|/)(__tests__/.*|.*\.(test|spec)\.[tj]sx?)$' || true)

ALL_TESTS=$(printf "%s\n%s\n" "$STAGED_TESTS" "$RANGE_TESTS" | sed '/^$/d' | sort -u)

if [ -n "$ALL_TESTS" ]; then
  echo "변경 또는 추가된 테스트 파일:"
  printf "%s\n" "$ALL_TESTS" | sed 's/^/   - /'
  echo "Push 전 변경 / 추가된 테스트 파일 테스트 단계 수행..."
  printf "%s\0" $ALL_TESTS | xargs -0 yarn jest --bail --maxWorkers=50% --passWithNoTests || exit 1
else
  echo "변경 또는 추가된 테스트 파일이 없어 테스트를 건너뜀!!"
fi

# 6. 코드 스타일 규칙 검증
echo "Push 전 엄격한 Lint 규칙 검증..."
yarn lint:strict || exit 1